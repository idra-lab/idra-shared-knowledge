Node description
================

The ``/joint_state_broadcaster`` node is part of the `ROS2 control package <https://control.ros.org/humble/index.html>`_.
More details can be found `here <https://control.ros.org/humble/doc/ros2_controllers/joint_state_broadcaster/doc/userdoc.html>`_,
but essentially the broadcaster reads all state interfaces and reports them on the ``/joint_states`` topic.

Such data is collected by the ``/robot_state_publisher`` node (package `Robot State
Publisher <https://github.com/ros/robot_state_publisher>`_) that combines the knowledge of
the robot's kinematics to publish the full tree of transformations for the different links
on the topics ``/tf`` and ``/tf_static``.

The ``/motion_control_handle`` node is implemented as a ROS2 control that
spawns an handle that can be moved in RViz that specifies the target position of the robot;
the information is published on the ``/target_frame`` topic.

.. |Unprecised:The target is collected by the ``/cartesian_motion_controller`` node (generated by the | replace:: \
.. |ROS2 control package but can load any custom controller that implements the| replace:: \
.. |``CartesianMotionController`` interface) that computes the commands to be sent to the| replace:: \
The target pose defined by the ``/motion_control_handle`` is actuated by the ``/cartesian_motion_controller``, which
is a kinematic ROS2 controller that connects to the hardware interface (``/robot_controller``) which loaded by the URDF.

The ``sim_ros2_interface`` node is instead provided by :ref:`CoppeliaSim<coppeliasim>` and
is the bridge between the ROS2 world (in which the control is computed) and the Coppelia
world (in which the system is simulated).

As mentioned `here <https://robotics.stackexchange.com/questions/104551/how-does-anything-listen-to-tf2-what-are-the-transform-listener-impl-nodes>`_,
the ``/transform_listener_impl_<>`` nodes are automatically spawned in order to ensure
a reliable transformation processing.

The ``/robot_controller`` is the hardware interface that connects Coppeliasim to the ROS2 control framework.
It is implemented reading the state from the robot and writing the command from the controller using ROS2 topics.

Finally, the standalone ``/controller_manager`` node, from ROS2 control, is the key node
that needs to be enabled to manage the ROS2 control framework. It is responsible for spawning, starting
and stopping the controllers.


